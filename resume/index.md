## About Me and My Education:
> Find me on different Social Platforms:
> 
> [<img src="https://github.com/user-attachments/assets/ab0831f0-2421-4dd6-83d0-429ef1d6f711" alt="https://github.com/pavly-gerges" width="40" height="40">](https://github.com/pavly-gerges)
> [<img src="https://github.com/user-attachments/assets/bf2a39df-8fed-4c01-9653-b724b14145b7" width="40" height="40">](https://www.youtube.com/@pavlg3944)
> [<img src="https://user-images.githubusercontent.com/60224159/180645937-40c0954c-03f4-4807-8063-7cd6ca917a7b.svg" width="40" height="40">](https://www.linkedin.com/in/pavly-gerges-420b81228/)
> [<img src="https://user-images.githubusercontent.com/60224159/181487461-63226149-2870-4446-a954-b4112a5cb26c.svg" width="40" height="40">](https://mail.google.com/mail/u/0/?fs=1&to=pepogerges33@gmail.com&su=SUBJECT&body=BODY&bcc=&tf=cm)
> [<img src="https://github.com/user-attachments/assets/1d96832a-b549-4598-a3e9-ce0709dbb0bc" width="40" height="40">](https://wa.me/201011912807)
> [<img src="https://user-images.githubusercontent.com/60224159/180646113-6531aec4-66bc-44d8-9ba5-d1857e87359a.svg" width="40" height="40">](https://twitter.com/g_pavl)

Welcome, it's an honor for me that you've reached here! I'm Pavly Gerges, aka. pavl_g, a common nickname used for API authorships and Open-Source Licenses for my projects, and the projects that I've contributed to. I'm essentially a self-taught OSS Engineer from the medical profession totally filled with the passion towards open-science and open-source Hardware/Software Engineering. I graduated from the [faculty of Medicine and Surgery, October 6 University](https://o6u.edu.eg/Faculties.aspx?FactId=2) in 2023 with GPA-3.15, and currently taking my medical internship. I am currently holding a Bachelor degree of Medicine and Surgery (M.B.B.Ch.), however, not entitled yet to practice medicine. Though I'm a medical candidate, I've got enough wisdom over these years to find the common scientific bases among Software Engineering and Medicine, which are very huge to list them here in this section. Comprehensively, through this genuine way, I've been able to focus on and study both fields. Regarding computer engineering, I'm currently studying Embedded Systems, and Game Engines Development among other pure sciences including, but not limited to, Calculus, Linear Algebra and Discrete Mathematics. As regard to medicine, I'm currently putting my focus on Critical Care, particularly the Neuro- and Cardio-pulmonary Critical Care, and I could tell you, that the ideas captured from studying the common scientific bases have tremendously helped me over this time. All my studies in both fields run from books, documentation manuals, technical reports, and journals, and rarely workshop webinar tutorials. I'll leave you with my compliments; that is "If you want to build something new, something ingenious, you have to have a structured way to conclude your approach and design your solution. No proceedings can be made without this point in-mind". To not make this section longer, you can read [my detailed journey to the tech industry here on this archived version](https://github.com/pavly-gerges/pavly-gerges/blob/main/resume/archived.md#my-journey-to-the-tech-industry).

## Skills:
- **Languages**: Java - Kotlin - C/C++ - Groovy - Bash (Shell Scripting).
- **Java Platform**: Java Reflection API - Java Native Interface (JNI) - JNI Invocation API - Java Command-line tools.
- **Gradle**: Gradle - Gradle Plugins - Gradle Core Platform Modular Architecture - Gradle Multi-project Builds.
- **Crossplatform API Design and development**: Software Architectural Design - Concurrent Programming - Object-oriented Design - Design Patterns - Entity-Component-System Design - Procedural Programming (Finite Automata) - Sqlite DB - Data Structures - Algorithms - POSIX - GNU Compiler Collection (GCC) - Android Core SDK - Android NDK - GLSL - OpenGL - PlantUML - Sonatype/Maven Deployment.
- **Technical Writing**: Documentation - Tutorials.
- **Building and Automation**: CMake - BASH - JUnit - Group Testing (jme3-testable pilot API) - Git/GitHub VCS - GitHub Actions (CI/CD) - Windows-Subsystem For Linux (WSL).
- **Embedded Systems**: C/C++ Programming - Java Native Interface (JNI) - Microcontroller Programming - GNU/Linux Libc - jMonkeyEngine Framework - Hardware/Software Co-design - Distributed Simulations.
- **Pure Sciences**: Scientific Modelling - Scientific Philosophy - Discrete Mathematics - Calculus - Linear Algebra - Applied Theory - Medical and Clinical Sciences - System Design.
- **Debugging and Profiling**: Java Utility Loggers (JUL) - jconsole - Android Profiler - Java Flight Recorder (JFR) - GNU Debugger (GDB).

## Experience:
> Essentially, all my contributions are entitled to open-source projects through different routes, either through non-profit open-source organizations (e.g., jMonkeyEngine - Pi4j) or through self-initiated projects on [Electrostat-Lab](https://github.com/Electrostat-Lab) organization, see the [projects section](https://github.com/orgs/Electrostat-Lab/repositories?language=&q=electrostat-lab&sort=&type=all).

### jMonkeyEngine Contributions: 
> Contributor | (2020 - Present)

I've been contributing to jMonkeyEngine, an open-source code-first approach complete 3D game engine suite written primarily in Java with GLSL Java bindings based on the OpenGL pipelines and modular API design, **for about 4 years**, and still contributing.

### What does the current jMonkeyEngine team do?
The current team activities are essentially:
- Maintaining the current codebase for cross-platform game applications development.
- Community Management.
- Features support and Engine Releases.
- Plugins, API design, and building sub-projects.

### What were [my activities](https://github.com/jMonkeyEngine/jmonkeyengine/commits?author=pavly-gerges) during this period?
- **JmeSurfaceView**: During my first year, I proposed and introduced [JmeSurfaceView](https://github.com/jMonkeyEngine/jmonkeyengine/tree/master/jme3-android/src/main/java/com/jme3/view/surfaceview), a GL Surface View handler component for embedding jMonkeyEngine Game Contexts into Android Layout Designs, and it's proven comptency over time in this pilot project [Game-HCI](https://github.com/Electrostat-Lab/Game-HCI), which houses reusable I/O Game GUI components leveraging the power of the MVC architectural patterns together with userinput lifecycle linkage through command-state and strategy patterns (i.e., controller interfaces). 

- **ContrastAdjustmentFilter**: I worked on another shiny feature, a [ContrastAdjustmentFilter](https://github.com/jMonkeyEngine/jmonkeyengine/pull/1665); that is essentially a postprocessor filter GLSL API that controls the 3D-color-gamut contrast using a power law, and was introduced in [jMonkeyEngine v3.5.0-beta4](https://github.com/jMonkeyEngine/jmonkeyengine/releases/tag/v3.5.0-beta4).

- **Writing JavaDoc for an Old Animation System (MonkeyAnim)**: I've taken the initiative in writing JavaDocs for a 7-year-old undocumented and vague animation system (MonkeyAnim), and succeeded with the team guidance to [deliver some of it](https://github.com/jMonkeyEngine/jmonkeyengine/pulls?q=is%3Apr+com.jme3.anim+is%3Aclosed+author%3Apavly-gerges) on the currently working release [jMonkeyEngine v3.7.0](https://github.com/jMonkeyEngine/jmonkeyengine/releases/tag/v3.7.0-alpha1).

- **Issues support and Community Management participations**: Other things that I had worked on in jMonkeyEngine are issues related to the Android [jme3-android](https://github.com/jMonkeyEngine/jmonkeyengine/commits/master/jme3-android?author=pavly-gerges) and the core modules [jme3-core](https://github.com/jMonkeyEngine/jmonkeyengine/commits/master/jme3-core?author=pavly-gerges).

- **Beginnings of the Serial4j framework**: I designed [Serial4j](https://github.com/Electrostat-Lab/Serial4j) back in 2021, a Java Terminal I/O framework for serial interfaces (e.g., Serial USB and RS232) based on the Data-Flow and the Data-centered architectural designs, in which I've blended a lot of my skills, including but not limited to, developing APIs using C/C++, building dynamic native libraries, using Gradle and CMake to build JNI applications, testing memory leaks, designing and implementing modal logic algorithms and byte-flow patterns, hardware/software co-design, plus introducing [a vision for distributed simulation systems](https://www.youtube.com/watch?v=4GFGsH4eyJs&t=235s).

### Pi4j Contributions: 
> Technical Writing | (2022)

Upon the request of one of the Pi4j community leader, I've published a hybrid project that utilizes both Pi4j-v1 and jMonkeyEngine framework as a [Pi4j-featured project](https://www.pi4j.com/featured-projects/joystick-game/); in which I presented a full tutorial on hooking an Analog-Digital Circuit (MCP3008) onto the RPI GPIO through the Serial-Peripheral Interface (SPI) protocol. The tutorial also adds insights on the generic circuits and the conceptual model behind ADCs and DACs circuits.

### Electrostat-Lab Open-source Contributions: 
> OSS Embedded and Android Projects | (2020 - Present)

During the last 2 years, I've started my own open-source projects at [Electrostat-Lab](https://github.com/Electrostat-Lab) organization. Electrostat-Lab projects tend to solve problems arising within different domains, mainly jMonkeyEngine community, and my unfinished game [JPluto Arcade Game](https://www.youtube.com/watch?v=HcerZ-8IWSo); which should utilize a wide aspect of Hardware/Software Co-design, so typically the rendering and physics pipelines are managed using jMonkeyEngine interfaces, while the controller interfaces are built using custom peripherals and interfaced over serial and networks. The current vision of the Electrostat-Lab organization is to provide [a fully-fledged POSIX-based Open-Source Distributed Simulation Framework](https://github.com/Electrostat-Lab/Electrostatic-Sandbox); and it does this perfectly by dividing the framework into several smaller frameworks and APIs of re-usable code.

### Gradle first exposure: 
> Discussions on GitHub | (2023)

My first exposure to the Gradle team was providing an explanation to [an issue with the JavaDoc tooling](https://github.com/gradle/gradle/issues/18274) and [this PR](https://github.com/gradle/gradle/pull/18417), particularly using the `--release ${V}` option with the JavaDoc tool. However, I haven't got the time enough to communicate with the team and provide a fix, in addition, the team had replied back that it might take a long delay time to proceed.

## Projects:
[My projects](https://github.com/orgs/Electrostat-Lab/repositories?language=&q=electrostat-lab&sort=&type=all) are located on the [Electrostat-Lab](https://github.com/Electrostat-Lab) GitHub organization. You can find them by typing `electrostat-lab` in the search to search for repositories with this tag. Of which, those are the most coolest projects that I've:

### Gradle-At-A-Glance
> [GitHub](https://github.com/Electrostat-Lab/Gradle-At-A-Glance) - [Overview Video](https://www.youtube.com/watch?v=vUyPf0jyFxQ)
>
> A critique project for the current Gradle Framework on the [gradle/gradle](https://github.com/gradle/gradle) repository featuring the Gradle platform modules and infrastructure, in addition to a fair comparison to a design of a home-made similar project using [the System-Entity-Structure/Model-Base Framework (SES/MB) for Modelling and Simulation](https://link.springer.com/chapter/10.1007/978-3-031-11085-6_1#Fig6), and [the Tricotyledon Theory of System Design (T3SD)](https://link.springer.com/chapter/10.1007/BFb0025045), known as "Ccoffee". Ccoffee is a provisional conceptual design for a virtual project written purely in the C programming language even providing services for hardware compatibility (i.e., Microcontrollers). The project is subdivided into multiple modules; where each module represents a collective solution for a sub-problem in the problems domain with a strong abstractive layer featuring the Hierarchial patterns, such that, the solution range involves `filesystem` module, `connection-handler` module, and `infrastructure` module. Those could be plain CMake modules or separated compilation units (e.g., static libraries). The most headache-producing part in Native project development is the building stage which is platform-specific, and it could be eliminated by using the `POSIX` interfaces and providing a clear way to pilot-building the project by itself using a wrapper API; which compiles, builds, and caches the project binaries for a faster second run. According to the software ontology involved, the `filesystem` module deals with the primitive filesystems operations and is subdivided internally to a couple of API; `FileGenerator` component, `FileLocator` component, `FileEditor` component, `FileExtractor` component, and `FileUtils` component for extra manipulation, while the `connection-handler` module is devoted to provide the basis for the RESTful APIs, and is basically composed of `ConnectionEstablishmentHandler` component, `ConnectionMonitorHandler` component, `ConnectionInputStreamHandler` component, `ConnectionOutputStreamHandler` component, and `ConnectionListeners` component, and part of this might be categorized as a specialization of the `filesystem` APIs (i.e., depends-on/assembly relationship). Last, is the `infrastructure` module, that provides the runtime infrastructure of the project, and it could be based completely on an external framework, for example [Jector](https://github.com/Electrostat-Lab/Jector), a DI framework that creates an environment of 3 objects; a dependency object (i.e., a task to execute), a driving object (i.e., the worker object), and an injector interface (i.e., the task binder and executor manager); the dependency object contains the delegation code that is utilized by the driving object, while the injector object role is to pass the dependency object to the actual driving object to complete its job. Essentially, the beneficence of using the C programming langauge and the GNU C Collection is that it provides the ability to ship the project or at least the most relevant parts of it to run on bare-metal RISC MCUs (e.g., the AVR ATMega32) which is superior to the current Gradle and other building tools like CMake, but a clear usage for this feature is not fully studied, yet. For the previously mentioned abstractions, specializations can be attained, such that they specialize the APIs in a one single direction. The `ProjectEntriesManager` and the `PlatformToolchainsManager` are 
specializations of the `FilesystemManager` interfaces, and the `RuntimeInfrastructureManager` is a specialization of the `AbstractRuntimeManager` interfaces from the `infrastructure` module, while the `ProjectBuildManager` is a new aspect of the building system that is composed of `SourceCompiler` component, `BinariesLinker` component, `BinariesAssembler` component, and `BinariesIncrementalLoader` component for caching the compile-time last date of modification and comparing it to the static source files in the project tree. The project also houses a couple of cool Gradle plugins, `Gradle-make` for Gradle~CMake integration, and `Gradle-dude` for [AVR-Dude](https://github.com/avrdudes/avrdude) integration for embedded systems projects.
> 
> Skills: Java - Java Reflection API - Gradle - Gradle Infrastructure - CMake - POSIX - GNU/Linux - Software Architecture - Design Patterns - Problem Analysis - Discrete Mathematics - Technical Writing

### jSnapLoader API
> [GitHub](https://github.com/Electrostat-Lab/jSnapLoader) - [Maven-central](https://central.sonatype.com/artifact/io.github.electrostat-lab/snaploader)
>
> A high-performance platform-independent Native Dynamic Library extractor and loader for JVM and Android Applications based on the Data-Flow and the Hierarchial Architectural patterns. This framework supports assets (e.g., gltf files and images) extraction, as well, through the `Filesystem` API provided there. The architecture basically divides the library into subsets of APIs; each of them solves a subset problem of the major problem. The library solves the most headache-producing problem in developing cross-platform native applications; which is creating predicates for each system in the form of nested conditional statements, this library solves the problem using formula objects known as _PlatformPredicates_, which are formed of `P(X) = (OS && CPU && ARCH)`, and thus new _PlatformPredicates_ could be built on the user application side and not primarily hard-coded into the main API leading to a robust design with simple ideas picked from Discrete Mathematics and Modal Logic. Additionally, the framework offers a stock onloading anti-failure mechanism, and a stepwise command-state pattern to handle failures from the user application side enabling the implementation of several anti-failure routines from the user side. Furthermore, memory logging and tight handling of stream resources are attained on both the normal program flow and the exceptional cases (i.e., failure cases). The framework is open-ended for user-based specializations and wrappers APIs, and is currently deployed to be used by [Jolt-jni](https://github.com/stephengold/snap-jolt/tree/master).
> 
> Skills: Java - Gradle - Software Architecture - Java Google Coding Standards - Discrete Mathematics - Crossplatform API Design - Sonatype/Maven Deployment - BASH - GitHub Actions (CI/CD) - jconsole - JUL - Software Testing

### Serial4j Framework
> [GitHub](https://github.com/Electrostat-Lab/Serial4j) - [TechDemo](https://www.youtube.com/watch?v=ebsMKR3PFVA)
>
> A Java terminal IO framework based on the GNU/Linux termios API for communication with peripheral devices using the serial interface (e.g., USB Serial, RS232, and PS/2). The base architecture of Serial4j is based on the Data-Flow Systems, particularly Pipe-and-Filter Architectural design, so from a low-level perspective, the Filesystems and byte streams, which is very analogus conceptually to serialization and deserialization, but on wire. The pipe is the plain filesystem and byte streams, while the filters are composed of main stream filters imposed by the operating system; that is the Terminal, that controls the byte streams providing buffered, unbuffered, and line feed/return carriage buffered stream routines. Other filters are mutually exclusive parts of the architecture known as _Human-Interface-Device_ APIs and _SerialMonitor APIs_; those provide new routines to manipulate byte streams as _Data Frames_; so essentially introducing a new type of buffered streams through accumulating data via modal logic (or boolean algebra aka. bitwise operations). The framework was designed essentially to provide innovators with custom controllers to bind to jMonkeyEngine Game Lifecycle, and do a lot of crazy stuff.
> 
> Skills: Java - C/C++ - JNI - GNU/Linux Libc - Gradle Multi-project - CMake - Software Architecture - Java Google Coding Standards - Emebedded Systems - Discrete Mathematics - Crossplatform API Design - Sonatype/Maven Deployment - BASH - Hardware/Software Co-design - GitHub Actions (CI/CD) - jconsole - JUL - Software Testing - Distributed Simulation Interfaces - jMonkeyEngine 

### Jector Framework
> [GitHub](https://github.com/Electrostat-Lab/Jector) - [TechDemo](https://www.youtube.com/watch?v=CjjXpxce37w) - [Maven-central](https://central.sonatype.com/artifact/io.github.software-hardware-codesign/jector)
>
> An advanced DI framework for JVM and Android applications based on the Java Reflection API with a specialized implementation for jMonkeyEngine Applications. Jector provides a programming concurrent (order-parallelism/sync) model for best practices by injecting functions' stacks into schedulable tasks, and in turn into their designated threads. Threads can be activated and controlled to achieve either parallelism or synchronicity. Its threading model could be used for assets asynchronous loading, async tasks execution, and mutual multithreading (threading using mutual events).
> 
> Skills: Java - Java Reflection API - Gradle - Concurrent Programming - jMonkeyEngine - Asynchronous Assets Loading - Object-oriented Programming - Dependency Injection (DI) - Threads - GitHub Actions (CI/CD) - Sonatype/Maven Deployment - BASH.

### Articular-ES Framework
> [GitHub](https://github.com/Electrostat-Lab/Articular-ES) - [TechDemo](https://www.youtube.com/watch?v=CnjUakuqlMI) - [Maven-central](https://central.sonatype.com/artifact/io.github.software-hardware-codesign/articular-es)
>
> An entity component system (ECS) framework featuring strong articulations among components from different systems through controller interfaces. The API is powered by a caching system that enables caching data in different configurations. Operational interactions take place within the system manager through the controller objects. The API provides a strong abstraction based on the data-centered architecture with the ability to model complex systems, such as: Human Interface Devices (HID) APIs, and language processing and translational APIs. The framework is composed structurally of `Systems`, `Entities`, `Modules`, and `Components`, while behaviorly of `SystemControllers` and `DataPipes`.
> 
> Skills: Java - Java Reflection API - Gradle - Entity-Component-System Architecture - Data-centered designs - Object-oriented Programming - jMonkeyEngine - GitHub Actions (CI/CD) - Game Development. 

### Automata4j Framework
> [GitHub](https://github.com/Electrostat-Lab/Automata4j) - [TechDemo](https://www.linkedin.com/feed/update/urn:li:activity:7014704404347949056/?updateEntityUrn=urn%3Ali%3Afs_updateV2%3A%28urn%3Ali%3Aactivity%3A7014704404347949056%2CFEED_DETAIL%2CEMPTY%2CDEFAULT%2Cfalse%29&originTrackingId=%2BI05adX4SQKtJ99ZQvk5DQ%3D%3D) - [Maven-central](https://central.sonatype.com/artifact/io.github.software-hardware-codesign/automata4j)
>
> A classic finite-states-automata (FSA) framework for JVM and Android applications featuring both the `Deterministic Finite Automata (DFA)` and the `Non-deterministic Finite Automata (NDFA)` together with the ability to cache states beforehand in finite-automata aggregates, through the `CascadedTransition` components, a type of finite-states transition path that superimposes cascaded paths through abstract `Queue` data structures.
> 
> Skills: Java - Java Reflection API - Gradle - Object-oriented Programming - Procedural Programming (Finite Automata) - Discrete Mathematics - jMonkeyEngine - Embedded Systems - GitHub Actions (CI/CD) - Unit Testing - Game Programming Patterns.

### Crossplatform-template for jMonkeyEngine Games using Gradle Multi-project
> [GitHub](https://github.com/Electrostat-Lab/Cross-platform-template) 
>
> A cross-platform template game for jMonkeyEngine providing compatibility for both desktop and android environments through Gradle multi-modular projects, in which a `core module` represents the common module among all platforms (i.e., Platform Independent Module), a `desktop` module for desktop-specific handlers (i.e., Desktop Window Managers), and an `android` module for android-specific handlers (i.e., Android Runtime Providers, Window, and Application Managers).
> 
> Skills: Java - Gradle Multiproject - jMonkeyEngine - Crossplatform Application Development 
>

### Electrostatic-Sandbox SDK Suite (WIP)
> [GitHub](https://github.com/Electrostat-Lab/Electrostatic-Sandbox) - [Website](https://electrostat-lab.github.io/Electrostatic-Sandbox/)
>
> A work-in-progress open-source code-first complete SDK and development suite for distributed simulation systems based on the IEEE-1516 High-level Architecture Interface, GNU/Linux Kernel userspace APIs, and NASA DSES. The infrastructure of the sytem is subdivided into `Networking Infrastructure`, `Software Infrastructure`, and `Simulation Infrastructure`. Essentially, the `Networking Infrastructure` is composed of a common communication protocol API abstracting off the different serial and parallel communication cores (e.g., TCP/IP, Serial Interfaces RS232 Standard and USB Standard, Parallel Standard IEEE-1284 or Centronics, Ethernet Standard IEEE-802.3), the `Software Infrastructure` is composed mainly of the firewall APIs, the database APIs, and the rest of operating system resources handler APIs (e.g., MemoryManagers and WindowManagers) in addition to the `Runtime Infrastructure (RTI)` and the `RTI Interfaces` defined by the [HLA IEEE-1516 Standard](https://standards.ieee.org/ieee/1516/3744/) for Distributed Simulation Systems; which entails the use of unified application development routines among the systems in communication known as _"Federates"_ and a common data exchange routine known as _"Federation Object Model (FOM)"_, while the instantiated runtime is known as _"Federation"_, and the `Simulation Infrastructure` is composed mainly of the Hardware/Software Connection Routines provided by the `Networking Infrastructure`, in addition to `Microcontroller programming` APIs and tools. The current repository introduces a preliminary vision and the tech demo from Serial4j.
> 
> Skills: Unix/POSIX - CMake - C/C++ Programming - Systems Engineering - Java - Gradle - BASH - Compilers Front-end APIs - API Design - Mathematics - Electronics - Embedded Systems - Embedded System Design - Networking Infrastructure - Distributed Simulations - Journals Study (NTRS/IEEE/ACM) - GitHub Actions.

### Jme3-testable API
> [GitHub](https://github.com/Electrostat-Lab/Jme3-testable) - [TechDemo](https://www.youtube.com/watch?v=u9biai9Yg38&t=27s)
>
> An API designed to provide the core for synchronous group testing through the Java Reflection API Annotations. This is an initial implementation for the testable api, targeting issue [jMonkeyEngine#1649](https://github.com/jMonkeyEngine/jmonkeyengine/issues/1649), which suggests building a better test chooser backend for jme3-examples, where one can pickup which test cases to run inside a package.
> 
> Skills: Java - Java Reflection API - Concurrent Programming - Gradle - jMonkeyEngine - Group Testing - Unit Testing.
>

### Game-HCI
> [GitHub](https://github.com/Electrostat-Lab/Game-HCI) - [TechDemo1](https://www.youtube.com/watch?v=Gp2JJ-PCI8c) - [TechDemo2](https://www.youtube.com/watch?v=Jog8FdHDeOU) - [Jitpack-io](https://jitpack.io/#Electrostat-lab/Game-HCI)
>
> An Android API housing useful re-usbable Human-computer Interfaces (HCI) in the form of in-game android views with an integration API for jMonkeyEngine featuring the Model-View-Controller (MVC) Architecture for designing GUI components and providing a binding API to the jMonkeyEngine Lifecycle. The API has a couple of cool ready-to-use components, including but not limited to, a `GameStickView` component and a `ControllerButtonsView` component, a `DrivingWheelView` component, a `GullWing` component for spacecrafts, a `Tachometer` and a `UTurnView` generically for vehicles, plus other Android Menustate items. The API is available on `Jitpack-io` for public use.
> 
> Skills: Java - Java Reflection API - Android SDK - Linear Algebra - Android Application Development - MVC Architectural design - Concurrent Programming - Gradle - jMonkeyEngine - Game Development.
>

### jme-alloc
> [GitHub](https://github.com/Electrostat-Lab/jme-alloc) - [Overview](https://www.youtube.com/watch?v=x1vHPwcLM_w)
>
> A direct dynamic memory allocation API for jMonkeyEngine lwjgl-2 and Android games featuring a GC-linked API for memory scavenging using `PhantomReference` that keeps track of the buffer reference counts (internally) and the memory address of the buffer to be scavenged when a GC generation is dispatched.
> 
> Skills: Java - Java Reflection API - JNI - Java Garbage Collectors - C/C++ Programming - jMonkeyEngine - Memory Algorithms - Memory Analytics - Unit Testing - jconsole
> 

### JoystickModule API for Raspberry Pi
> [GitHub](https://github.com/Electrostat-Lab/JoyStickModule) - [Pi4j-featured-project](https://www.pi4j.com/featured-projects/joystick-game/) - [TechDemo](https://www.youtube.com/watch?v=9ZvhFQSwHF0) - [Jitpack-io](https://jitpack.io/#Electrostat-Lab/JoystickModule)
>
> A Java API to control a Jme Vehicle/CharacterControl/etc with an arduino JoyStick module using Pi4J-v1 implemented from native WiringPI featuring the ADC-SPI circuit, the SPI protocol, and some simple trigonometry are involved in defining the mapping for the Joystick input threshold.
> 
> Skills: Java - Gradle - Pi4jv1 - jMonkeyEngine - Embedded Systems Design - Raspberry Pi GPIO - Technical Writing - Digital Electronics.
> 

### ShiftAvr Framework 
> [GitHub](https://github.com/Electrostat-Lab/ShiftAvr) - [TechDemo](https://www.linkedin.com/feed/update/urn:li:activity:7051549167554375681/?updateEntityUrn=urn%3Ali%3Afs_updateV2%3A%28urn%3Ali%3Aactivity%3A7051549167554375681%2CFEED_DETAIL%2CEMPTY%2CDEFAULT%2Cfalse%29&originTrackingId=%2BLQ7QpzJQ4uLz6ngNdXFjQ%3D%3D)
>
> A modern implementation of avr-core and GNU libraries for avr microcontroller units purely written in C expressing abstract interfaces for the communication protocols, everything is plain, right fresh out of the avr-gnu-libc documentation and the AVR datasheets.
> 
> Skills: C/C++ Programming - CMake Multi-project - BASH - Toolchain Front-end APIs - Microcontroller Programming - Embedded Systems - Byte-flow algorithms - Embedded Systems Design - Electronics.
>

